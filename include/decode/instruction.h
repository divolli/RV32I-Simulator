#ifndef INSTRUCTION_H
#define INSTRUCTION_H

#include "utils/defs.h"

// Decoded instruction structure - represents a fully decoded RV32I instruction
typedef struct {
  uint32_t raw_instruction;

  // Instruction fields (directly from encoding)
  uint8_t opcode;     // bits [6:0]
  uint8_t rd;         // bits [11:7] - destination register
  uint8_t funct3;     // bits [14:12]
  uint8_t rs1;        // bits [19:15] - source register 1
  uint8_t rs2;        // bits [24:20] - source register 2
  uint8_t funct7;     // bits [31:25]

  // Immediate values (sign-extended appropriately for each format)
  int32_t imm_i;      // I-type: bits [31:20], sign-extended
  int32_t imm_s;      // S-type: bits [31:25,11:7], sign-extended
  int32_t imm_b;      // B-type: bits [31,7,30:25,11:8], sign-extended, shifted left 1
  uint32_t imm_u;     // U-type: bits [31:12], shifted left 12
  int32_t imm_j;      // J-type: bits [31,19:12,20,30:21], sign-extended, shifted left 1

  // Decoded instruction information
  instruction_format_t format;
  instruction_type_t type;
  bool is_valid;

  // PC of this instruction (filled during fetch)
  uint32_t pc;
} instruction_t;

// Control signals generated by instruction decoder - matches real processor design
typedef struct {
  // Register file control
  bool reg_write_enable;          // Write to register file
  uint8_t reg_write_source;       // 0=ALU, 1=memory, 2=PC+4

  // ALU control
  alu_operation_t alu_op;         // ALU operation to perform
  bool alu_src_b_is_immediate;    // 0=register, 1=immediate for ALU input B

  // Memory control
  memory_operation_t mem_op;      // Memory operation type
  memory_size_t mem_size;         // Size of memory access
  bool mem_load_unsigned;         // For loads: 0=sign extend, 1=zero extend

  // Branch/Jump control
  bool is_branch;                 // Instruction is a branch
  bool is_jump;                   // Instruction is a jump (JAL/JALR)
  bool is_jump_register;          // 0=JAL, 1=JALR

  // PC control
  uint8_t pc_source;              // 0=PC+4, 1=branch target, 2=jump target

  // System control
  bool is_system_call;            // ECALL instruction
  bool is_breakpoint;             // EBREAK instruction
  bool is_fence;                  // FENCE instruction

  // Pipeline control hints
  bool causes_stall;              // Instruction may cause pipeline stall
  bool flushes_pipeline;          // Instruction flushes pipeline
} control_signals_t;

// Function declarations for instruction processing
instruction_t decode_instruction(uint32_t raw_instruction, uint32_t pc);
control_signals_t generate_control_signals(const instruction_t* instruction);
const char* instruction_to_string(const instruction_t* instruction);
void print_instruction_detailed(const instruction_t* instruction);

// Immediate extraction functions (used internally by decoder)
int32_t extract_i_immediate(uint32_t instruction);
int32_t extract_s_immediate(uint32_t instruction);
int32_t extract_b_immediate(uint32_t instruction);
uint32_t extract_u_immediate(uint32_t instruction);
int32_t extract_j_immediate(uint32_t instruction);

#endif // INSTRUCTION_H

/*
typedef union {
  uint32_t word;                // Raw 32-bit instruction

  // R-type: register operations (ADD, SUB, AND, OR, etc.)
  struct {
    uint32_t funct  : 6;      // Function code (bits 0-5)
    uint32_t shamt  : 5;      // Shift amount (bits 6-10)
    uint32_t rd     : 5;      // Destination register (bits 11-15)
    uint32_t rt     : 5;      // Target register (bits 16-20)
    uint32_t rs     : 5;      // Source register (bits 21-25)
    uint32_t opcode : 6;      // Operation code (bits 26-31)
  } r_type;

  // I-type: immediate operations (ADDI, LW, SW, BEQ, etc.)
  struct {
    uint32_t immediate : 16;  // Immediate value (bits 0-15)
    uint32_t rt        : 5;   // Target register (bits 16-20)
    uint32_t rs        : 5;   // Source register (bits 21-25)
    uint32_t opcode    : 6;   // Operation code (bits 26-31)
  } i_type;

  // J-type: jump operations (J, JAL)
  struct {
    uint32_t address : 26;    // Jump address (bits 0-25)
    uint32_t opcode  : 6;     // Operation code (bits 26-31)
  } j_type;
} instruction_t;
*/
